---
title: "Validator Economics: Proposer selection"
author:
- name: Sandra Johnson
  url: https://twitter.com/sandJohnson
  affiliation: Consensys Software Inc (Research Group)
date: "`r Sys.Date()`"
description: 
  Visualisation of proposer selection probabilities for increased maximum effective balance.
editor_options: 
  markdown: 
    wrap: 72
---

This R script is in GitHub \~/rig-sandbox/R scripts The output is
included in the document "Validator Economics: Variable min validator
deposit size, EF Academic Grant ID: FY23-1030, DRAFT MODEL, CHALLENGES &
POTENTIAL MITIGATIONS (MAXEB - EIP-7521)" The source LaTeX files are in
GitHub \~/validator-economics/documents

```{r message=FALSE}
library(data.table)
library(ggplot2)
#library(glue)          # Not really using glue in this Notebook, but it is useful!
#library(jsonlite)
library(knitr)
library(lubridate)
library(rmarkdown)
library(skimr)
library(tidyverse)

options(digits=10)
options(scipen = 999) 

# See knit options in https://www.r-bloggers.com/2021/03/default-knitr-options-and-hooks/ 
knitr::opts_chunk$set(dpi = if (knitr::is_latex_output()) 72 else 300,
                      echo=FALSE)
```

## Proposer selection

The probability of a proposer being selected is the result of the
following process: 1) The validator indices are shuffled 2) A random
byte is generated 2) The code iterates through this list, starting at
the first entry and moving to the next candidate index if the current
one does not pass the test The check is based on two variables: the
candidate validator's effective balance and the random byte generated,
and two constants: the maximum bytes number (255) and the maximum
effective balance = 2.048 ETH (previously 32 ETH)

Here we calculate the probability distribution using various
consolidation options.

```{r cache=TRUE}
set.seed(1)

random_byte_values <- runif(770000,0,255)

plot(density(random_byte_values),
     main="Generating 770,000 observations from Uniform(0,255)", xlab("Random byte values") ) 
     
# abline(v=127.5, col = "steelblue")
# abline(v=127.5, col = "springgreen4")
abline(v=127.5, col = "firebrick4")

# Expected mean = 255/2 = 127.5 and the variance is (b-a)^2 / 12 = (255^2)/12 = 5,418.75

# Probability that a validator is selected as a proposer for the next block, given that their candidate index is the current one being checked:
# P(random_byte >= (255*EB) \ MaxEB)
```
## Blog post - graph of 716,800 randomly drawn values from U(0,255)
- After the values have been drawn, we need to ensure that they are all integer values. We cannot have values greater than 255, so we use the floor function to round down to the nearest integer value.
```{r cache=TRUE}
set.seed(1)

random_byte_values <- runif(716800,0,255)
## ----------------------------------------------
r_int <- floor(random_byte_values)
x <- seq(0,255,1)
r <- data.frame(r_int)

df <- r %>%
  group_by(r_int) %>%
  summarise(y = n()) %>%
  arrange(r_int)

df <- df %>%
  mutate(prob = y/sum(y))

head(df)
     
ggplot(data=df, aes(x=r_int,y=prob))  +
  xlab("random_byte values generated from U(0,255)") +
  ylab("proportion of validator set") +
  geom_point()  
ggsave("/Users/sandra/data/rig/plots/random-values-generated.png") 


```



```{r}
## Example scenarios: SCENARIO 1
#  ------------------
# Here we do the same as the previous chunk, but with a slightly smaller validator set (716,800) to make the calculations simpler

set.seed(1)

random_byte_values <- runif(716800,0,255)

png(filename="/Users/sandra/data/rig/plots/validator-indices-density.png")

validator_indices_density <- plot(density(random_byte_values),
     main="Generating 716,800 values from Uniform(0,255)", xlab("Random byte values") ) 
     
# abline(v=127.5, col = "steelblue")
# abline(v=127.5, col = "springgreen4")
abline(v=127.5, col = "firebrick4")

dev.off()

# Expected mean = 255/2 = 127.5 and the variance is (b-a)^2 / 12 = (255^2)/12 = 5,418.75, SE = 73.61

# Probability that a validator is selected as a proposer for the next block, given that their candidate index is the current one being checked:
# P(random_byte >= (255*EB) \ MaxEB)
# Scenario 1: All validators are solo stakers
# -------------------------------------------
validator_idx <- seq(0,716799)
proposers_scenario_1_DF <- data.table(validator_idx, random_byte_values)
proposers_scenario_1_DF_MaxEB <- proposers_scenario_1_DF %>%
  mutate(selected = case_when(
      random_byte_values <= (255*32)/2048 ~ "yes",
      TRUE ~ "no")
    )
maxeb_solo <- proposers_scenario_1_DF_MaxEB %>% 
  count(selected)

proposers_scenario_1_DF_current <- proposers_scenario_1_DF %>%
  mutate(selected = case_when(
      random_byte_values <= (255*32)/32 ~ "yes",
      TRUE ~ "no")
    )

current_solo <- proposers_scenario_1_DF_current %>% 
  count(selected)


# Note: geom_col() to use the bar to represent the values in the data
# ----  geom_bar() makes the height of the bar proportional to the number of cases in each group

current_solo_barchart <- ggplot(data=current_solo) + 
  geom_col(aes(x=selected, y=n, fill=selected)) +
  scale_fill_manual(values=c("turquoise2","white")) +
  xlab("Was candidate index selected as proposer?") +
  ylab("Number of validators") 
ggsave("/Users/sandra/data/rig/plots/current-solo-barchart.png")

maxeb_solo_barchart <- ggplot(data=maxeb_solo) + 
  geom_col(aes(x=selected, y=n, fill=selected)) +
  xlab("Was candidate index selected as proposer?") +
  ylab("Number of validators") 
ggsave("/Users/sandra/data/rig/plots/maxeb-solo-barchart.png")

# Check to see which validator indices were set to "accept"
# ----------------------------------------------------------
selected_validators <- proposers_scenario_1_DF_MaxEB[which(proposers_scenario_1_DF_MaxEB$selected=='yes')]   # 
first_selected_validator <- selected_validators$validator_idx[1]           ## >>> This was 26, so not a big deal really!!

```

## Scenario 2: All the validators have consolidated to the new increased maximum effective balance

-   Using total deposit size as before, i.e. equivalent to 716,800
    validators, will now have an active validator set size of 11,200
-   Generate random bytes to simulate a possible outcome of random bytes
    assigned to each validator.
-   The probability of being chosen based on the effective balance will
    again be 100%, so really this scenario is not of interest, just
    interesting to see how small it got.

## Scenario 3: The active validator set comprises of a "mixed bag" of validators: single stakers, partially consolidated and fully consolidated

Based on the 716,800 active validator set:
- 30% fully consolidated (64-fold) - 3,360 validators with 2048 ETH.   (A)
- 10% partially consolidated (10-fold) - 7,168 validators with 320 ETH (B)
- 10% partially consolidated (5-fold) - 14,336 validators with 156 ETH (C)
- 20% partially consolidated (2-fold) - 71,680 validators with 64 ETH. (D)
- 30% single stake (1-fold) - 215,040 validators with 32 ETH           (E)
Therefore active validator set size = 311,584    

First shuffle the validator types & then generate random bytes for each validator before running through the check for acceptance.



```{r}
set.seed(5394)

random_byte_values <- runif(311584,0,255)

# Scenario 3: Mixture of validators
# -------------------------------------------
validator_idx <- seq(0,311583)
proposer_types <-c(rep(c("A"), times=3360),
                   rep(c("B"), times=7168),
                   rep(c("C"), times=14336),
                   rep(c("D"), times=71680),
                   rep(c("E"), times=215040))

proposers_scenario_3_DF_ordered <- data.table(validator_idx, random_byte_values, proposer_types)
proposers_scenario_3_DF_shuffled <- proposers_scenario_3_DF_ordered %>%
  mutate(shuffled_proposer_types = sample(proposer_types)) %>%
  mutate(selected = case_when(
      (shuffled_proposer_types == "A") & (random_byte_values <= (255*2048)/2048) ~ "yes",
      (shuffled_proposer_types == "B") & (random_byte_values <= (255*320)/2048) ~ "yes",
      (shuffled_proposer_types == "C") & (random_byte_values <= (255*156)/2048) ~ "yes",
      (shuffled_proposer_types == "D") & (random_byte_values <= (255*64)/2048) ~ "yes",
      (shuffled_proposer_types == "E") & (random_byte_values <= (255*32)/2048) ~ "yes",
      TRUE ~ "no")
    )

scenario_3_count <- proposers_scenario_3_DF_shuffled %>% 
  group_by(shuffled_proposer_types) %>%
  count(selected)

scenario3_barchart <- ggplot(data=scenario_3_count) + 
#  geom_col(aes(x=shuffled_proposer_types,y=n, fill=selected)) +
  geom_col(aes(x=shuffled_proposer_types,y=n,  fill=selected), position = "dodge") +
  xlab("Was candidate index selected as proposer?") +
  ylab("Number of validators") 

ggsave("/Users/sandra/data/rig/plots/scenario3_barchart.png")

# Check if there is another way of showing the relative yes to no selections...
# scenario3_barchart2 <- ggplot(data=scenario_3_count) + 
#   geom_bar(aes(x=shuffled_proposer_types, fill=selected), position = "dodge") +
#   xlab("Was candidate index selected as proposer?") +
#   ylab("Number of validators") 

#ggsave("/Users/sandra/data/rig/plots/scenario3_barchart2.png")

# Check to see which validator indices were set to "accept"
# ----------------------------------------------------------
selected_validators_scenario_3 <- proposers_scenario_3_DF_shuffled[which(proposers_scenario_3_DF_shuffled$selected=='yes')]   # 
first_selected_validator_scenario_3 <-selected_validators_scenario_3[1] %>%
  select(validator_idx,proposer_type=shuffled_proposer_types,selected)                  ## validator index = 0, and proposer type = B

# Run simulations to see what happens over time


# Note that in scenario 3, the apart from the change in the probability of a candidate index being selected as a proposer, the probability of being selected if you are a fully consolidated validator is hugely reduced. In this example we have the probability of being the candidate index as 3,360/311,584 = 0.0108 - approx 1.08%
# In summary - I will include a table in the document to show how the dynamics change for this scenario.
# 
```


## Draw a plot of EB (horizontal axis) vs the probability of passing the test (vertical axis). 
```{r}
x <- c(32, 64, 160, 320, 960, 2048)
y <- c(0.015625, 0.03125, 0.078125, 0.15625, 0.46875, 1.00)

proposer_check <- data.frame(x,y)

proposer_check_graph <- ggplot(data=proposer_check, aes(x=x,y=y)) +
                        geom_line() +
                        xlab("validator effective balance") +
                        ylab("probability of passing proposer check") +
                        xlim(32,2048) +
                        ylim(0,1) +
                        geom_segment(aes(x = 32, y = 0, xend = 32, yend = 0.015625, colour="firebrick"))
proposer_check_graph <- proposer_check_graph +
                        geom_segment(aes(x = 64, y = 0, xend = 64, yend = 0.03125, colour="turquoise")) 
proposer_check_graph <- proposer_check_graph +
                        geom_segment(aes(x = 160, y = 0, xend = 160, yend = 0.078125, colour="gold"))
proposer_check_graph <- proposer_check_graph +
                        geom_segment(aes(x = 320, y = 0, xend = 320, yend = 0.15625, colour="grey")) 
proposer_check_graph <- proposer_check_graph +
                        geom_segment(aes(x = 960, y = 0, xend = 960, yend = 0.46875, colour="green4"))
proposer_check_graph <- proposer_check_graph +
                        geom_segment(aes(x = 2048, y = 0, xend = 2048, yend = 1, colour="pink")) 
proposer_check_graph <- proposer_check_graph +
                        labs(colour="Validator\nConsolidation") +
                        scale_colour_manual(labels = c("32 ETH", "64 ETH", "160 ETH", "320 ETH", "960 ETH", "2,048 ETH"), 
                                          values = c("firebrick", "turquoise", "gold", "grey", "green4", "pink"))

# The order of the segments appear incorrectly!! Not sure why??? 

# ANSWER!!! used aes, e.g. geom_segment(aes(x = 2048, y = 0, xend = 2048, yend = 1, colour="pink")) & aes does lazy evaluation - changed code & thought it was working as desired, but then there was no legend :(

ggsave("/Users/sandra/data/rig/plots/proposer_check_graph.png")
```
## Blog post: Negative binomial of proposer eligibility check
Model the number of failures (i.e. not passing the proposer check) before a validator passes the check to become the next proposer
```{r}
n = 716800       # number of draws 
size = 1         # number of successes
prob = 0.015625  # probability of success
negative_bin <- rnbinom(n, size, prob)

median_failures <- median(negative_bin)

# probability of fewer than 100 failures
pnbinom(c(100), size, prob, lower.tail = TRUE, log.p = FALSE)

# probability of more than 100 failures
pnbinom(c(100,200,300,400), size, prob, lower.tail = FALSE, log.p = FALSE)

hist(negative_bin,                                         
     breaks = 500,
     main = "",
     xlab='Number of proposer check failures',
     xlim=c(0,500),
     ylim = c(0,35000))


```
## Blog post: Uniform distribution for generation of random bytes - U(0,255)
Generate a histogram of the number of times different integer values were assigned to validators

```{r}
## ===========================================================
## This histogram uses frequency for the y-axis
## ===========================================================
set.seed(1)

random_integers <- floor(runif(716800, 0, 255))

hist(random_integers,                                         
     breaks = 500,
     main = "",
     xlab='random_byte values generated from U(0,255)',
     ylab='number of validators'
     ) 


# Plot the random integers generated by the spec & overlay a uniform distribution
# Copied to public repo :)
# -------------------------------------------------------------------------------
transparentlightblue <- rgb(173,216,230,max = 255, alpha = 80) # using transparent colour for uniform dist

ggplot(r, aes(x=r_int)) + geom_histogram(bins = 255, aes(y=..density..)) +
   stat_function(fun = dunif, args = list(min = 0, max = 255), geom = "area", 
                  fill = transparentlightblue) + 
    stat_function(fun = dunif, args = list(min = 0, max = 255)) +
  xlab("random bytes generated in 'compute_proposer_index'") +
  ylab("proportion of validators")

ggsave("/Users/sandra/data/rig/plots/random-integers-and-uniform.png")

```

## Example R code

```{r}
set.seed(1)

random_byte_values <- runif(716800,0,255)
## ----------------------------------------------
r_int <- floor(random_byte_values)
x <- seq(0,255,1)
r <- data.frame(r_int)

df <- r %>%
  group_by(r_int) %>%
  summarise(y = n()) %>%
  arrange(r_int)

ggplot(df, aes(sample = r_int)) +
  stat_qq() + stat_qq_line() +
  ylim(0,255)

library(lattice)

ggplot(df, aes(sample = r_int)) +
  stat_qq() +                         # Default dist is nornal
  stat_qq_line()

# =======================
# Flipped coordinates :D
# NOTE: qplot has been deprecated, so need to use ggplot instead
# ========================
qplot(sample = r_int, distribution = qunif, 
  xlab = "uniform distribution quantiles",
  ylab= "random bytes generated from spec",
  colour = I("turquoise")) +
  stat_qq_line(distribution = qunif((1/256),min = 0, max = 255,lower.tail = FALSE, log.p = FALSE), aes(colour="black")) +
#  geom_qq_line(sample=runif(1000,0,255)) +
  coord_flip()                                    # Need to try to fit the actual Q-Q line for a uniform distribution! 

 # geom_line(x=r_int, )

# Using ggplot instead (above is deprecated)
# ------------------------------------------
p <- 1/256

gg_eg <- ggplot(r, aes(sample=r_int)) +    
  stat_qq(distribution = qunif(p,0,255))

# Running now
# ------------
# --------
p <- 1/256
p_eg <- ggplot(r, aes(sample = r_int), group = 1) + ylim(0,255)
p_eg + stat_qq(distribution=qunif, colour = "turquoise")  # no errors
#p_eg + stat_qq(distribution=qunif, colour = "turquoise") + stat_qq_line(distribution = qunif) # ERROR:[38;5;232m`geom_path()`: Each group consists of only one observation.
#p_eg + stat_qq(distribution=qunif, colour = "turquoise") + stat_qq_line(distribution=qunif,colour = "black") # errors
#p_eg + stat_qq(distribution=qunif,geom="line", size=0.5) + stat_qq_line(distribution=qunif, dparams = c(1/256,0,255))
# =====>
# Same errors as above for geom_.. functions !!
p_eg <- ggplot(r, aes(sample = r_int), group = 1) + ylim(0,255)
p_eg + geom_qq(distribution=qunif, colour = "turquoise")  # no errors
#p_eg + geom_qq(distribution=qunif, colour = "turquoise") + geom_qq_line(distribution = qunif) # ERROR:[38;5;232m`geom_path()`:

# Posted code below for generating the Q-Q plot to the public repo
# ----------------------------------------------------------------
ggplot() +
  geom_qq(data=r, aes(sample=r_int), colour = "turquoise", distribution=qunif) +
  geom_abline(slope=255,intercept=0) +
  coord_flip()

ggsave(ggsave("/Users/sandra/data/rig/plots/random-integers-QQ.png"))

```


The preview shows you a rendered HTML copy of the contents of the
editor. Consequently, unlike *Knit*, *Preview* does not run any R code
chunks. Instead, the output of the chunk when it was last run in the
editor is displayed.
