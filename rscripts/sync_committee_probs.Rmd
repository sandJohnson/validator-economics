---
title: "Validator Economics: Sync committee selection"
author:
- name: Sandra Johnson
  url: https://twitter.com/sandJohnson
  affiliation: Consensys Software Inc (Research Group)
date: "`r Sys.Date()`"
description: 
  Calculation and visualisation of sync committee selection probabilities for increased maximum effective balance.
editor_options: 
  markdown: 
    wrap: 72
---

This R script is in GitHub \~/rig-sandbox/R scripts The output is
included in the document "Validator Economics: Variable min validator
deposit size, EF Academic Grant ID: FY23-1030, DRAFT MODEL, CHALLENGES &
POTENTIAL MITIGATIONS (MAXEB - EIP-7521)" The source LaTeX files are in
GitHub \~/validator-economics/documents

```{r message=FALSE}
library(data.table)
library(ggplot2)
#library(glue)          # Not really using glue in this Notebook, but it is useful!
#library(jsonlite)
library(knitr)
library(lubridate)
library(rmarkdown)
library(skimr)
library(tibble)
library(tidyverse)

options(digits=10)
options(scipen = 999) 

# See knit options in https://www.r-bloggers.com/2021/03/default-knitr-options-and-hooks/ 
knitr::opts_chunk$set(dpi = if (knitr::is_latex_output()) 72 else 300,
                      echo=FALSE)
```
## Fetch R functions to use
```{r}
source("sync_functions.R")
```


## Sync committee selection

The probability of a validator being selected to participate in the sync committee
adheres to the following process: 
1) The validator indices are shuffled 
2) One candidate validator results from the shuffled index
3) A random byte is generated for this candidate (note this candidate may have been chosen before & more than likely with a different generated random byte)
4) A comparison is made between the candidate validator's effective balance * maximum bytes value (255) and MaxEB * random byte generated. If the first term is bigger than the second, then the validator is added to the sync committee.
5) Another iteration of the loop is executed until we have chosen enough validators (each member of the committee is present >= 1) to make up the sync committee

This appears to be very similar at first glance to proposer selection, but the difference here is that 
we are sampling WITH REPLACEMENT. Therefore each validator could be chosen more than once and the probabilities of being chosen do not change with each draw.

(NB: CHECK THAT PROPOSER SELECTION DOES IN FACT SAMPLE W/O REPLACEMENT, BECAUSE LOOKING AT THE CODE IT DOES NOT APPEAR TO ME TO BE THE CASE!!)

###  Generate 255 random bytes that we will use to combine with validators selected from the active validator set

```{r cache=TRUE}
# Generate 255 random bytes that we will use to combine with validators selected from the active validator set
# ------------------------------------------------------------------------------------------------------------
set.seed(1)

random_byte_values_sync <- runif(7680,0,255)
## ----------------------------------------------
r_int_sync <- floor(random_byte_values_sync)
r_sync <- tibble(r_int_sync)

df_sync_random <- r_sync %>%
  group_by(r_int_sync) %>%
  summarise(y = n()) %>%
  arrange(r_int_sync)

# Check proportions of random values generated
df_sync_random_sync  <- df_sync_random  %>%
  mutate(prob = y/sum(y)) 



```



```{r}
# ---------------------------------------------------------------------------------------
#' Example Scenario: prior to EIP-7521
#' -----------------------------------
#' - Three staker groups: A, B, C
#' - All validators owned by the three staker groups are solo stakers
#' - A, B, and C have all staked the same amount, i.e. run the same number of validators
# ---------------------------------------------------------------------------------------
```
# Example Scenario: prior to EIP-7521

- The total number of validators (n) in the active validator set is more than 255 (2560*3=7680) 
- Three staker groups: A, B, C
- All validators owned by the three staker groups are solo stakers
- A, B, and C have all staked the same amount, i.e. run the same number of validators = 2560

```{r}

```
## Example Scenario: post EIP-7521

 - The total number of validators (n) in the active validator set is more than 255 (128*3=384) 
 - Three staker groups: A, B, C
 - The validators owned by the three staker groups have been consolidated in different ways
 - A, B, and C have all staked the same amount, so even though the number of validators owned by each group may differ, they all have the same number of virtual validators.

### NOTE: The concept of a virtual validator needs to work with validators that are not  multiples of 32 ETH.
Reason being once we are compounding to various validators we will have validators that have fractions of 32 ETH added to them over time.

- What we want to visualise is the probability distribution for membership of the sync committee for each of the staker groups:
 1. As is currently the case
 2. After EIP-7521 has been implemented
```{r}
# Binomial distribution for sync committee selection
# ---------------------------------------------------
# Pre-EIP-7521, the probability of one of the validators of each of the stakers being in the
# sync committee is given by:
scenario_pre_EIP7521_prob <- 1/3          # 2560/7680 

# For each of the groups, we want to visualise the probability that one of their validators is chosen to be included in the sync committee
# P(X >= 1) = 1 - P(X=0), i.e. it is 1 - probability that none of the validators in that staker group is in the sync committee

# This is the density of the probability of the number of validators selected for the sync committee test
n_sync <- 255       # sync committee size 
x <- seq(0,255,1)
p_bin <- scenario_pre_EIP7521_prob
pre_eip_dbin <- dbinom(x,n_sync, p_bin)

plot(x,dbinom(x,n_sync, p_bin),
     type='h',
     ylab ='Probability',
     xlab = 'Validator selected'
     )
```

## PROCESS OF SELECTING SYNC COMMITTEE MEMBERS

 1. Shuffle index of validators (shuffled_index)
 2. Assign candidate index (candidate_index <- shuffled_index)
 3. Generate a random byte for that candidate
 4. Check if the candidate passes the test
 5. Yes - a. add to sync committee  if membership count is not yet 512
        - b. increment membership counter
 6. No - do not increment membership counter & pass through the loop again

```{r}
# We need to combine a candidate with the randomly generated value & check if it passes the test
# Note that a validator may be selected more than once & each time a new random byte will be assigned

#' EXAMPLE SCENARIO, PRE-EIP7521: 
#' ------------------------------
#' Total validator set size - 7,680, three stakers, each with 2,560 validators
# Shuffle the entire set each time to draw the next candidate
# -------------------------------------------------------------------------------------
active_validators_df <- tibble(
  staker = sample(c(rep("A",2560), rep("B",2560), rep("C", 2560))),
)

# Note we are assuming that all validators have 32 ETH EB
# Pre-EIP-7521 all validators will pass the sync committee check
# We are therefore only really looking at how many validators have been selected 
# more than once to join the sync committee

sync_committee_df <- assign_sync_committee(active_validators_df)
sync_committee_unique_df <- assign_unique_sync_mbrs(sync_committee_df) 

# Running the above grouping had values of 490 and 495 unique validators.
# Being a small validator set this is unsurprising

# Check staker representation in the sync committee
# Appears to be a similar distribution for the 3 staking groups in the large active validator set
sync_staker_totals_df <- assign_total_sync_stakers(sync_committee_df)

# Perhaps we need to do this for the current validator set size!!
# Using 900,000 for active validator set size & repeat the above procedure
# ========================================================================
active_validators_df_now <- tibble(
  staker = sample(c(rep("A",300000), rep("B",300000), rep("C", 300000))),
  selected = rep(0,900000)
)
sync_committee_df_now <- assign_sync_committee(active_validators_df_now)
sync_committee_unique_df_now <- assign_unique_sync_mbrs(sync_committee_df_now) 

# As expected no duplicates when the active validator set is so large, there were no validators
# elected to the sync committee more than once ^^

# Let us also look at how the stakers fared. They all had the same number of validators and 
# all validators had 32 ETH with MaxEB = 32 ETH
sync_staker_totals_df_now <- assign_total_sync_stakers(sync_committee_df_now)

## TODO: Plot proportion of stake (each 1/3) against the proportional 
## ----  representation in the sync committee (A: 152/512, B: 187/512, C: 173/512)
##                                            (A: 0.298,   B: 0.365,   C: 0.338 )
# ======================================================================================
```
## Explore sync committee membership in post-EIP-7521 Ethereum

```{r}
# Sync committee selection post-EIP-7521
# Example scenario as described in the "DRAFT MODEL, CHALLENGES & POTENTIAL MITIGATIONS (MAXEB - EIP-7521)" document
# --------------------------------------
active_validators_df_maxeb <- tibble(
  staker = c(rep("A",2560), rep("B",40), rep("C", 520)),
  EB = c(rep(32,2560), rep(2048,40), rep(32,280), rep(64,100), rep(160,80), rep(320,40), rep(2048,20))
)

# Shuffle the validator set
active_validators_df_maxeb_shuffled <- active_validators_df_maxeb[sample(1:nrow(active_validators_df_maxeb)), ] 


# Assign sync committee in a post-EIP-7521 era
# 
# Note: Executing the procedures below we notice a large descrepancy in the
# ----  proportional representation of the types of validators in the committee
#       However, these numbers are small relative to current validator numbers
#       We found that there were only 303 unique validator indices in the committee
# ---------------------------------------------------------------------------------
sync_committee_df_maxeb <- assign_maxeb_sync_committee(active_validators_df_maxeb_shuffled)
sync_committee_unique_df_maxeb <- assign_unique_sync_mbrs(sync_committee_df_maxeb)
sync_staker_totals_df_maxeb <- assign_total_sync_stakers(sync_committee_df_maxeb)
# Another interesting grouping would be the validator EB for each staker:
sync_staker_totals_EB_df_maxeb <- assign_total_sync_stakers_EB(sync_committee_df_maxeb)

## ====================================================================================+
## Use current values of active validator set, ignoring staker groups (?), but         |
## distribution across various consolidated validators   
## Validator set total = 900,000
## Staker A: All single: 300,000 (=300,000)
## Staker B: 1x: 2; 30x: 1; 64x: 4687 (=4,690)
## Staker C: 1x: 50,024; 2x: 25,000; 5x: 10,000; 10x: 5,000; 30x: 1,660; 64x: 784 (=92,468)

## ====================================================================================+
active_validators_df_maxeb_now <- tibble(
  staker = c(rep("A",300000), rep("B",4690), rep("C", 92468)),
  EB = c(rep(32,300002), rep(960,1), rep(2048,4687), rep(32,50024), rep(64,25000), rep(160,10000), rep(320,5000), rep(960,1660),rep(2048,784)) 
)

# Shuffle the validator set
active_validators_df_maxeb_shuffled_now <- active_validators_df_maxeb_now[sample(1:nrow(active_validators_df_maxeb_now)), ] 

sync_committee_df_maxeb_now <- assign_maxeb_sync_committee(active_validators_df_maxeb_shuffled_now)
sync_committee_unique_df_maxeb_now <- assign_unique_sync_mbrs(sync_committee_df_maxeb_now)
sync_staker_totals_df_maxeb_now <- assign_total_sync_stakers(sync_committee_df_maxeb_now)
# Another interesting grouping would be the validator EB for each staker:
sync_staker_totals_EB_df_maxeb_now <- assign_total_sync_stakers_EB(sync_committee_df_maxeb_now)

## >>>>>>>>>>>>>>>>>>
## TODO!! VISUALISE OUTPUT (PROPORTIONAL SYNC COMMITTEE MEMBERSHIP VS VALIDATOR SET MEMBERSHIP)
## >>>>>>>>>>>>>>>>>>


# Post-EIP-7521 for three staking groups: A, B & C
scenario_post_EIP7521_prob_A <- 2560/3020   # single stake (unconsolidated)
scenario_post_EIP7521_prob_B <- 40/3020     # maxEB stake
scenario_post_EIP7521_prob_C <- 520/3020    # varying consolidation 

# Post-EIP-7521 for four consolidated validator types
scenario_post_EIP7521_prob_single  <- 2840/3020  #  1 x 32 ETH
scenario_post_EIP7521_prob_single  <- 100/3020    #  2 x 32 ETH
scenario_post_EIP7521_prob_5_fold  <- 80/3020    #  5 x 32 ETH
scenario_post_EIP7521_prob_10_fold <- 40/3020    # 10 x 32 ETH
scenario_post_EIP7521_prob_maxEB   <- 60/3020    # 64 x 32 ETH



```
## Probabilities and Expected values
```{r}
# Totals for each type of validator
active_validators_df_maxeb_now_EB_totals <- active_validators_df_maxeb_now %>%
  group_by(EB) %>%
  summarise(selected = n()) 

# Totals for each staker
active_validators_df_maxeb_now_staker_totals <- active_validators_df_maxeb_now %>%
  group_by(staker) %>%
  summarise(selected = n()) %>%
  mutate(prob = selected/397158)

# Totals by staker & validator type
active_validators_df_maxeb_now_staker_EB_totals <- active_validators_df_maxeb_now %>%
  group_by(staker, EB) %>%
  summarise(total = n(), .groups = 'keep') %>%  # summarise with both grouping vars (default is 'drop_last')
  mutate(prob = total/397158) %>%
  arrange(EB,staker)
```

